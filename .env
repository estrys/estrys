# DO NOT EDIT THIS FILE
# create an non-versioned .env.local one instead

# The port the server will listen on
ADDRESS=:8080

# Set here your public instance URL
DOMAIN=http://localhost

# Set here a twitter application token (not an oauth)
# See the get-started readme for more info
TOKEN=

# You should defined here a list of allowed users to use this instance
# This is a comma separated list of usernames.
# You can also allow a full instance, but this is not recommended
# Example : ALLOWED_USERS=someone@instance.io,someoneelse@another-instance.io,@allow-all-instance.io
ALLOWED_USERS=

# This is a coma separated list of allowed twitter users to be bridged on this instance
TWITTER_ALLOWED_USERS=

# Set the log level, could be trace, debug, info, warning, error
LOG_LEVEL=info

# Configure this to point to your redis instance
REDIS_ADDRESS=redis:6379

# Configure address to your postgres instance
DB_URL=postgres://estrys:estrys@db/estrys?sslmode=disable

# This is the TTL of twitter user metadata (user name and description, tweets count, followers count, following count)
# Those info are kept in cache for the amount of time configured below.
# After the expiration, new meta will be fetched from twitter in an ondemand way
# (if endpoints that need those data are reached)
CACHE_TWITTER_USER_TTL=5m

# This is the TTL of tweets stored locally, by default the estrys instance will keep tweets forever
# If you set this to a lower period, expect to have som 404 to the statuses endpoints
CACHE_TWEET_TTL=

# Disable http signature verification
# DO NOT ENABLE THIS FOR PRODUCTION ENVIRONMENTS
# That should be used for local development purposes only
DISABLE_HTTP_SIGNATURE_VERIFY=false

# By default the background worker are handled in the same process than the API
# It is recommended to disable this behavior with this flag and scale workers separately in a production environment
DISABLE_EMBED_WORKER=false

RUN_MIGRATIONS=true

# If this value is set then errors will be catched and send to sentry
SENTRY_DSN=
